#!/usr/bin/env python
#
# // SPDX-License-Identifier: BSD-3-CLAUSE
#
# (C) Copyright 2018, Xilinx, Inc.
#

import argparse
import collections
import os.path
import math
import sys
import timeit
import xdnn, xdnn_io
import numpy as np
from multiprocessing import Process, Queue
from ctypes import *

import datetime

g_doQuant = False
g_fpgaCfgFile = ""
g_scaleA = 10000
g_scaleB = 30
g_raw_scale = 255.0
g_mean = [104.007, 116.669, 122.679] # BGR for Caffe
g_input_scale = 1.0 # 1.0 for GoogLeNet and ResNet, 0.017 for MobileNet
g_img_shape = [3, 224, 224]

g_xdnnTestDataDir = "data/googlenet_v1"
g_fpgaOutputSize = 1024
g_outputSize = 1000
g_firstFpgaLayerName = "conv1/7x7_s2"
g_labelFile = "synset_words.txt"
g_goldenFile = None
g_xclbin = "kernel.xclbin"
g_netFile = "googlenet.fpgaaddr.64.txt"
g_xdnnLib = "libxblas.so"
g_inputImageDir = None
g_allInputImageFiles = None
g_allInputImageFilesReadIdx = 0
g_batchSize = 8
g_numDevices = 1
g_inputs = None
g_inputbuf = None
g_imgbuf = None
g_useBlas = False
g_zmqPub = False
g_perpetual = False
g_xdnnv3 = False

def processCommandLine():
  global g_xclbin
  global g_netFile
  global g_fpgaCfgFile
  global g_xdnnTestDataDir
  global g_labelFile
  global g_goldenFile
  global g_inputImageDir
  global g_xdnnLib
  global g_doQuant
  global g_fpgaOutputSize
  global g_outputSize
  global g_firstFpgaLayerName
  global g_useBlas
  global g_zmqPub
  global g_perpetual
  global g_batchSize
  global g_xdnnv3
  global g_raw_scale
  global g_mean
  global g_input_scale
  global g_PE
  global g_batchSize

  parser = argparse.ArgumentParser(description='pyXDNN')
  parser.add_argument('--usexdnnv3', action='store_true',
    help='version of xdnn')
  parser.add_argument('--xclbin',
    help='.xclbin file')
  parser.add_argument('--netcfg',
    help='FPGA instructions generated by compiler for the network')
  parser.add_argument('--quantizecfg',
    help='FPGA config file')
  parser.add_argument('--xlnxlib',
    help='FPGA xfDNN lib .so')
  parser.add_argument('--fpgaoutsz',
    help='size of 1 FPGA output blob')
  parser.add_argument('--outsz',
    help='size of 1 output blob')
  parser.add_argument('--firstfpgalayer',
    help='name of first FPGA layer (to start quantization)')
  parser.add_argument('--datadir',
    help='path to data files to run for the network')
  parser.add_argument('--labels',
    help='result -> labels translation file')
  parser.add_argument('--img_raw_scale', type=float, default=255.0,
    help='image raw scale value ')
  parser.add_argument('--img_mean', type=tuple, default=[104.007, 116.669, 122.679],  # BGR for Caffe
    help='image mean values ')
  parser.add_argument('--img_input_scale', type=float, default=1.0,
    help='image input scale value ')
  parser.add_argument('--golden',
    help='file idx -> expected label file')
  parser.add_argument('--imagedir',
    help='directory with image files to classify')
  parser.add_argument('--useblas', action='store_true',
    help='use BLAS-optimized functions (requires xfDNN lib compiled with BLAS)')
  parser.add_argument('--zmqpub', 
    help='publish predictions to zmq port 5555')
  parser.add_argument('--perpetual', 
    help='loop over input images forever')
  parser.add_argument('--batchSize', 
    help='Images to process in parallel')
  parser.add_argument('--PE', help='PE')  
  args = parser.parse_args()

  if os.path.isfile(args.xclbin) and os.access(args.xclbin, os.R_OK):
    g_xclbin = args.xclbin
  else:
    sys.exit("ERROR: Specified xclbin file does not exist or is not readable.")

  if os.path.isfile(args.netcfg) and os.access(args.netcfg, os.R_OK):
    g_netFile = args.netcfg
  else:
    sys.exit("ERROR: Specified netcfg file does not exist or is not readable.")

  if os.path.isfile(args.quantizecfg) and os.access(args.quantizecfg, os.R_OK):
    g_fpgaCfgFile = args.quantizecfg
    g_doQuant = True
  else:
    sys.exit("ERROR: Specified quantizecfg file does not exist or is not readable.")

  if os.path.isfile(args.xlnxlib) and os.access(args.xlnxlib, os.R_OK):
    g_xdnnLib = args.xlnxlib
  else:
    sys.exit("ERROR: Specified xlnxlib file does not exist or is not readable.")

  if args.fpgaoutsz:
    g_fpgaOutputSize = int(args.fpgaoutsz)
  if args.outsz:
    g_outputSize = int(args.outsz)
  if args.firstfpgalayer:
    g_firstFpgaLayerName = args.firstfpgalayer

  if os.path.isdir(args.datadir) and os.access(args.datadir, os.R_OK):
    g_xdnnTestDataDir = args.datadir
  else:
    sys.exit("ERROR: Specified datadir directory does not exist or is not readable.")

  if os.path.isfile(args.labels) and os.access(args.labels, os.R_OK):
    g_labelFile = args.labels
  else:
    sys.exit("ERROR: Specified labels file does not exist or is not readable.")

  if os.path.isfile(args.golden) and os.access(args.golden, os.R_OK):
    g_goldenFile = args.golden
  else:
    sys.exit("ERROR: Specified golden file does not exist or is not readable.")

  if os.path.isdir(args.imagedir) and os.access(args.imagedir, os.R_OK):
    g_inputImageDir = args.imagedir
  else:
    sys.exit("ERROR: Specified imagedir directory does not exist or is not readable.")
  if args.batchSize:
    g_batchSize = int(args.batchSize)
    print ("Running w/ BatchSize %d" % g_batchSize)
  if args.usexdnnv3:
    g_batchSize = 1
    g_xdnnv3 = True
  if args.useblas:
    g_useBlas = True
  if args.zmqpub:
    g_zmqPub = True
  if args.perpetual:
    g_perpetual = True
  if args.img_raw_scale:
    g_raw_scale = float(args.img_raw_scale)
  if args.img_mean:
    g_mean = args.img_mean
  if args.img_input_scale:
    g_input_scale = float(args.img_input_scale)
  if args.PE:
    g_PE = int ( args.PE)
  else:
    g_PE = -1
  
def prep_process(q):
  ret = xdnn.createManager(g_xdnnLib)
  if ret != True:
    sys.exit(1)

  while True:
    (inputs, inputImageFiles) = prepareImages()
    if inputs is None:
      break
    fpgaInputs = xdnn.quantizeInputs(g_firstFpgaLayerName, g_fpgaCfgFile, g_scaleB, inputs)
    q.put((fpgaInputs, inputImageFiles))

  q.put((None, None))

def xdnn_process (qFrom, qTo):
    xdnn_handle = xdnn.createHandle(g_xclbin, "kernelSxdnn_0", g_xdnnLib, g_numDevices)
    if xdnn_handle != 0:
       sys.exit(1)      
    args = { 'datadir': g_xdnnTestDataDir, 
             'quantizecfg': g_fpgaCfgFile, 
             'scaleA': g_scaleA, 
             'scaleB': g_scaleB,
             'PE': -1, 
             'netcfg': g_netFile }
    if g_xdnnv3 == True:
      weightsBlob = xdnn_io.loadWeightsBiasQuantv3(args)
    else:
      weightsBlob = xdnn_io.loadWeightsBiasQuant(args)
    fpgaOutput = prepareOutput(g_batchSize)
    while True:
        (inputs, inputImageFiles) = qFrom.get()
        if inputs is None:
          break

        fpgaInputs = prepareFpgaInputs(inputs)
        if not fpgaInputs:
          break
      
        startTime = timeit.default_timer()        
        xdnn.execute(g_netFile,
          weightsBlob, fpgaInputs, fpgaOutput,
          g_batchSize,  # num batches
          g_fpgaCfgFile, g_scaleB, g_PE)
        
        qTo.put((fpgaOutput, inputImageFiles))
        
        print "[time] FPGA xdnn execute (%.2f ms):" % ( (timeit.default_timer() - startTime ) * 1000)          
    
    qTo.put ((None, None))
    xdnn.closeHandle()        

class ZmqResultPublisher:
  def __init__(self):
    import zmq
    self.context = zmq.Context()
    self.socket = self.context.socket(zmq.PUB)
    self.socket.bind("tcp://*:5555")

  def send(self, data):
    self.socket.send(data)
        
def main():
  processCommandLine()
  ret = xdnn.createManager(g_xdnnLib)
  if ret != True:
    sys.exit(1)
      
  (fcWeight, fcBias) = xdnn_io.loadFCWeightsBias(g_xdnnTestDataDir)

  # 
  # Spawn the first 2 stages of our pipeline
  # Stage 1: Process JPG
  # Stage 2: Run FPGA "classify"
  qPrep = Queue(maxsize=1)
  qFpga = Queue(maxsize=1)
  prepProc = Process(target=prep_process, args=(qPrep,))  
  xdnnProc = Process(target=xdnn_process, args=(qPrep, qFpga))  
  prepProc.start() 
  xdnnProc.start() 

  #
  # The rest of this function post-processes FPGA output:
  # 1) Compute the final FC + Softmax layers
  # 2) Print classification & accuracy
  # 
  zmqPub = None
  if g_zmqPub:
    zmqPub = ZmqResultPublisher()
  goldenMap = None
  if g_goldenFile:
    goldenMap = getGoldenMap(g_goldenFile, g_labelFile)
  numProcessed = 0
  allTop1 = 0
  allTop5 = 0
  while True:    
    loopTime = timeit.default_timer()
    (fpgaOutput, inputImageFiles) = qFpga.get()

    if type(fpgaOutput) == type(None) \
      and type(inputImageFiles) == type(None):
      break
    
    startTime = timeit.default_timer()
    
    fcOutput = xdnn.computeFC(fcWeight, fcBias, fpgaOutput,
      g_batchSize, g_outputSize, g_fpgaOutputSize, g_useBlas)
    
    elapsedTime = timeit.default_timer() - startTime
    print "[time] FC (%.2f ms)" % (elapsedTime * 1000)
    
    startTime = timeit.default_timer()
    smaxOutput = xdnn.computeSoftmax(fcOutput, g_batchSize)
    elapsedTime = timeit.default_timer() - startTime
    #print "\nAfter Softmax (%.2f ms):" % (elapsedTime * 1000)

    numProcessed += g_batchSize

    (top1, top5) = printClassification(smaxOutput.flatten().tolist(), 
      g_outputSize, inputImageFiles, g_labelFile, goldenMap,
      zmqPub=zmqPub)
    if goldenMap:
      print "Accuracy (i=%d) Top-1: %d, Top-5: %d" \
        % (numProcessed/g_batchSize, top1, top5)
    allTop1 += top1
    allTop5 += top5

    print "Num processed: %d" % numProcessed
    print "\n[time] Total loop (%.2f ms)" % ( (timeit.default_timer() - loopTime ) * 1000)

  if goldenMap and numProcessed: 
    print "\nAverage accuracy (n=%d) Top-1: %.1f%%, Top-5: %.1f%%\n" \
      % (numProcessed, 
         float(allTop1)/float(numProcessed)*100., 
         float(allTop5)/float(numProcessed)*100.)

  prepProc.join()
  xdnnProc.join()

def prepareImages():
  global g_allInputImageFiles
  global g_allInputImageFilesReadIdx
  global g_perpetual
  global g_inputs, g_inputbuf
  if g_allInputImageFiles is None:
    # first time -- collect files from dir
    from os import listdir
    from os.path import isfile, join
    dirents = listdir(g_inputImageDir)
    #dirents = dirents[:4096] # ANDBG
    g_allInputImageFiles = [join(g_inputImageDir, f) \
      for f in dirents if isfile(join(g_inputImageDir, f))]

    numOrigImages = len(g_allInputImageFiles)
    numTestImages = g_batchSize
    if numOrigImages > 0 and numOrigImages < numTestImages:
      # batch size is greater than available images
      # fill up to batch size by reusing existing images
      i = 0
      while len(g_allInputImageFiles) < numTestImages:
        g_allInputImageFiles.append(g_allInputImageFiles[i])
        i = (i+1) % numOrigImages

  startTime = timeit.default_timer()
  if g_allInputImageFilesReadIdx >= len(g_allInputImageFiles):
    return (None, None)

  img_c = 3
  img_h = 224
  img_w = 224
  if g_inputs is None:
    g_inputs = np.zeros((g_batchSize, img_c,img_h,img_w), dtype=np.float32)
    g_inputbuf = np.zeros((g_batchSize, img_c, img_h, img_w), dtype=np.float32)

  inputImageFiles = []
  img_num = 0
  if g_allInputImageFiles:
      # use raw image files from user
    while img_num < g_batchSize \
      and g_allInputImageFilesReadIdx < len(g_allInputImageFiles):
      fname = g_allInputImageFiles[g_allInputImageFilesReadIdx]
      inputImageFiles.append(fname)

      imgStartTime = timeit.default_timer()
      g_inputs[img_num] \
        = xdnn_io.loadImageBlobFromFile(fname, g_raw_scale, g_mean, g_input_scale, img_h, img_w)
      imgElapsedTime = timeit.default_timer() - imgStartTime
      print "[time] loadImageBlobFromFile/OpenCV (%.2f ms)" \
        % (imgElapsedTime * 1000)

      img_num += 1
      g_allInputImageFilesReadIdx += 1
      if g_perpetual:
        g_allInputImageFilesReadIdx \
          = g_allInputImageFilesReadIdx % len(g_allInputImageFiles)
  
  print "[time] prepareImages (%.2f ms):" % ((timeit.default_timer() - startTime) * 1000)

  return (g_inputs, inputImageFiles)

def prepareFpgaInputs(inputs):
  fpgaInputs = xdnn.prepareInputsForFpga(inputs, g_fpgaCfgFile, g_scaleB, -1, g_firstFpgaLayerName)

  return fpgaInputs

def prepareOutput(num):
  (fpgaOutput, fpgaHandle) \
     = xdnn.makeFPGAFloatArray(g_fpgaOutputSize * num)

  return fpgaOutput

def getGoldenMap(goldenFile, labelFile):
  goldenMap = collections.OrderedDict()
  with open(goldenFile, 'r') as f:
    for line in f:
      fname = line[:line.rfind(' ')]
      goldenIdx = int(line[line.rfind(' ')+1:])
      goldenMap[fname] = goldenIdx

  return goldenMap

def checkAccuracy(fname, result, goldenMap):
  # get idx from file name ILSVRC2012_val_00031091.JPEG
  goldenIdx = goldenMap[fname]

  # result is in the form [(value, idx), (value, idx), ...]
  for i,(val,idx) in enumerate(result):
    if i == 0 and idx == goldenIdx:
      return (1, 1)
    elif idx == goldenIdx:
      return (0, 1)

  return (0, 0)

def printClassification(output, outputSize, inputImageFiles, labelFile, goldenMap=None, zmqPub=None):
  labels = []
  with open(labelFile, 'r') as f:
    for line in f:
      labels.append(line.strip())

  idxArr = [i for i in range(outputSize)]

  top1count = 0
  top5count = 0

  print "\n"
  zmqMessage = ""
  batch_size = len(inputImageFiles)
  for i in range(batch_size):
    print "---------- Prediction %d/%d for %s ----------" \
      % (i, batch_size-1, inputImageFiles[i])
    if zmqPub:
      zmqMessage += "%s\n" % inputImageFiles[i]
    startIdx = i * outputSize

    vals = output[startIdx:startIdx + outputSize]
    top5 = sorted(zip(vals, idxArr), reverse=True)[:5]

    for j in range(len(top5)):
      confidence = top5[j][0]
      label = labels[top5[j][1]]
      print "%.4f - \"%s\"" % (confidence, label)
      if zmqPub:
        zmqMessage += "%.4f %s\n" % (confidence, label)
    print ""

    if goldenMap != None:
      (t1, t5) = checkAccuracy(os.path.split(inputImageFiles[i])[1], top5, goldenMap)
      top1count += t1
      top5count += t5

  if zmqPub:
    zmqPub.send(zmqMessage)

  return (top1count, top5count)

if __name__ == '__main__':
  main()

