##################################################################################
# Copyright (c) 2017, Xilinx, Inc.
# All rights reserved.
# 
# Redistribution and use in source and binary forms, with or without modification,
# are permitted provided that the following conditions are met:
#
# 1. Redistributions of source code must retain the above copyright notice,
# this list of conditions and the following disclaimer.
# 
# 2. Redistributions in binary form must reproduce the above copyright notice,
# this list of conditions and the following disclaimer in the documentation
# and/or other materials provided with the distribution.
#
# 3. Neither the name of the copyright holder nor the names of its contributors
# may be used to endorse or promote products derived from this software
# without specific prior written permission.
#
# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
# THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
# IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
# OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
# EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
##################################################################################


#!/usr/bin/python

import argparse
import os.path
import math
import sys
import timeit
import xdnn, xdnn_io
import numpy as np
from multiprocessing import Process, Queue
from ctypes import *

import datetime

g_doQuant = False
g_fpgaCfgFile = ""
g_scaleA = 10000
g_scaleB = 30
g_mean = [104.007, 116.669, 122.679] # BGR for Caffe
g_img_shape = [3, 224, 224]

g_xdnnTestDataDir = "data/googlenet_v1"
g_fpgaOutputSize = 1024
g_outputSize = 1000
g_firstFpgaLayerName = "conv1/7x7_s2"
g_labelFile = "synset_words.txt"
g_goldenFile = None
g_xclbin = "kernel.xclbin"
g_netFile = "googlenet.fpgaaddr.64.txt"
g_xdnnLib = "libxblas.so"
g_inputImageDir = None
g_allInputImageFiles = None
g_batchSize = 4
g_numDevices = 1
g_inputs = None
g_inputbuf = None
g_imgbuf = None
g_useBlas = False

def processCommandLine():
  global g_xclbin
  global g_netFile
  global g_fpgaCfgFile
  global g_xdnnTestDataDir
  global g_labelFile
  global g_goldenFile
  global g_inputImageDir
  global g_xdnnLib
  global g_doQuant
  global g_fpgaOutputSize
  global g_outputSize
  global g_firstFpgaLayerName
  global g_useBlas

  parser = argparse.ArgumentParser(description='pyXDNN')
  parser.add_argument('--xclbin',
    help='.xclbin file')
  parser.add_argument('--netcfg',
    help='FPGA instructions generated by compiler for the network')
  parser.add_argument('--quantizecfg',
    help='FPGA config file')
  parser.add_argument('--xlnxlib',
    help='FPGA xfDNN lib .so')
  parser.add_argument('--fpgaoutsz',
    help='size of 1 FPGA output blob')
  parser.add_argument('--outsz',
    help='size of 1 output blob')
  parser.add_argument('--firstfpgalayer',
    help='name of first FPGA layer (to start quantization)')
  parser.add_argument('--datadir',
    help='path to data files to run for the network')
  parser.add_argument('--labels',
    help='result -> labels translation file')
  parser.add_argument('--golden',
    help='file idx -> expected label file')
  parser.add_argument('--imagedir',
    help='directory with image files to classify')
  parser.add_argument('--useblas', action='store_true',
    help='use BLAS-optimized functions (requires xfDNN lib compiled with BLAS)')
  args = parser.parse_args()

  if args.xclbin:
    g_xclbin = args.xclbin
  if args.netcfg:
    g_netFile = args.netcfg
  if args.quantizecfg:
    g_fpgaCfgFile = args.quantizecfg
    g_doQuant = True
  if args.xlnxlib:
    g_xdnnLib = args.xlnxlib
  if args.fpgaoutsz:
    g_fpgaOutputSize = int(args.fpgaoutsz)
  if args.outsz:
    g_outputSize = int(args.outsz)
  if args.firstfpgalayer:
    g_firstFpgaLayerName = args.firstfpgalayer
  if args.datadir:
    g_xdnnTestDataDir = args.datadir
  if args.labels:
    g_labelFile = args.labels
  if args.golden:
    g_goldenFile = args.golden
  if args.imagedir:
    g_inputImageDir = args.imagedir
  if args.useblas:
    g_useBlas = True

def prep_process(q):
  ret = xdnn.createManager(g_xdnnLib)
  if ret != True:
    sys.exit(1)

  cInputBuffer = None
  cFpgaInputBuffer = None
  while True:
    (inputs, inputImageFiles) = prepareImages()
    if inputs is None:
      break

    fpgaInputs = xdnn.quantizeInputs(g_firstFpgaLayerName, 
      inputs, cInputBuffer, cFpgaInputBuffer, g_fpgaCfgFile, g_scaleB)

    q.put((fpgaInputs, inputImageFiles))

  q.put((None, None))

def xdnn_process (qFrom, qTo):
    xdnn_handle = xdnn.createHandle(g_xclbin, "kernelSxdnn_0", g_xdnnLib, g_numDevices)
    if xdnn_handle != 0:
       sys.exit(1)      
    args = { 'datadir': g_xdnnTestDataDir, 
             'quantizecfg': g_fpgaCfgFile, 
             'scaleA': g_scaleA, 
             'scaleB': g_scaleB,
             'PE': -1 }
    weightsBlob = xdnn_io.loadWeightsBiasQuant(args)
    fpgaOutput = prepareOutput(g_batchSize)
    while True:
        (inputs, inputImageFiles) = qFrom.get()
        if inputs is None:
          break

        fpgaInputs = prepareFpgaInputs(inputs)
        if not fpgaInputs:
          break
      
        startTime = timeit.default_timer()        
        xdnn.execute(g_netFile,
          weightsBlob, fpgaInputs, fpgaOutput,
          g_batchSize,  # num batches
          1,  # num img per batch
          g_fpgaCfgFile, g_scaleB)
        
        qTo.put((fpgaOutput, inputImageFiles))
        
        print "[time] FPGA xdnn execute (%.2f ms):" % ( (timeit.default_timer() - startTime ) * 1000)          
    
    qTo.put ((None, None))
    xdnn.closeHandle()        
        
def main():
  processCommandLine()
  ret = xdnn.createManager(g_xdnnLib)
  if ret != True:
    sys.exit(1)
      
  (fcWeight, fcBias) = xdnn_io.loadFCWeightsBias(g_xdnnTestDataDir)

  # 
  # Spawn the first 2 stages of our pipeline
  # Stage 1: Process JPG
  # Stage 2: Run FPGA "classify"
  qPrep = Queue(maxsize=1)
  qFpga = Queue(maxsize=1)
  prepProc = Process(target=prep_process, args=(qPrep,))  
  xdnnProc = Process(target=xdnn_process, args=(qPrep, qFpga))  
  prepProc.start() 
  xdnnProc.start() 

  #
  # The rest of this function post-processes FPGA output:
  # 1) Compute the final FC + Softmax layers
  # 2) Print classification & accuracy
  # 
  goldenMap = None
  if g_goldenFile:
    goldenMap = getGoldenMap(g_goldenFile, g_labelFile)
  numProcessed = 0
  allTop1 = 0
  allTop5 = 0
  while True:    
    loopTime = timeit.default_timer()
    (fpgaOutput, inputImageFiles) = qFpga.get()

    if type(fpgaOutput) == type(None) \
      and type(inputImageFiles) == type(None):
      break
    
    startTime = timeit.default_timer()
    
    fcOutput = xdnn.computeFC(fcWeight, fcBias, fpgaOutput,
      g_batchSize, g_outputSize, g_fpgaOutputSize, g_useBlas)
    
    elapsedTime = timeit.default_timer() - startTime
    print "[time] FC (%.2f ms)" % (elapsedTime * 1000)
    
    startTime = timeit.default_timer()
    smaxOutput = xdnn.computeSoftmax(fcOutput, g_batchSize)
    elapsedTime = timeit.default_timer() - startTime
    #print "\nAfter Softmax (%.2f ms):" % (elapsedTime * 1000)

    numProcessed += g_batchSize

    (top1, top5) = printClassification(smaxOutput.flatten().tolist(), 
      g_outputSize, inputImageFiles, g_labelFile, goldenMap);
    if goldenMap:
      print "Accuracy (i=%d) Top-1: %d, Top-5: %d" \
        % (numProcessed/g_batchSize, top1, top5)
    allTop1 += top1
    allTop5 += top5

    print "Num processed: %d" % numProcessed
    print "\n[time] Total loop (%.2f ms)" % ( (timeit.default_timer() - loopTime ) * 1000)

  if goldenMap and numProcessed: 
    print "\nAverage accuracy (n=%d) Top-1: %.1f%%, Top-5: %.1f%%\n" \
      % (numProcessed, 
         float(allTop1)/float(numProcessed)*100., 
         float(allTop5)/float(numProcessed)*100.)

  prepProc.join()
  xdnnProc.join()

def prepareImages():
  global g_allInputImageFiles
  global g_inputs, g_inputbuf
  if g_allInputImageFiles is None:
    # first time -- collect files from dir
    from os import listdir
    from os.path import isfile, join
    dirents = listdir(g_inputImageDir)
    #dirents = dirents[:64]
    g_allInputImageFiles = [join(g_inputImageDir, f) \
      for f in dirents if isfile(join(g_inputImageDir, f))]

    numOrigImages = len(g_allInputImageFiles)
    numTestImages = g_batchSize
    if numOrigImages > 0 and numOrigImages < numTestImages:
      # batch size is greater than available images
      # fill up to batch size by reusing existing images
      i = 0
      while len(g_allInputImageFiles) < numTestImages:
        g_allInputImageFiles.append(g_allInputImageFiles[i])
        i = (i+1) % numOrigImages

  startTime = timeit.default_timer()
  if not g_allInputImageFiles:
    return (None, None)

  img_c = 3
  img_h = 224
  img_w = 224
  if g_inputs is None:
    g_inputs = np.zeros((g_batchSize, img_c*img_h*img_w), dtype=np.float32)
    g_inputbuf = np.zeros((g_batchSize, img_c, img_h, img_w), dtype=np.float32)

  inputImageFiles = []
  img_num = 0
  if g_allInputImageFiles:
      # use raw image files from user
    while img_num < g_batchSize and len(g_allInputImageFiles) > 0:
        fname = g_allInputImageFiles.pop(0)
        inputImageFiles.append(fname)

        imgStartTime = timeit.default_timer()
        g_inputs[img_num] \
          = xdnn_io.loadImageBlobFromFile(fname, g_mean, img_h, img_w)
        imgElapsedTime = timeit.default_timer() - imgStartTime
        print "[time] loadImageBlobFromFile/OpenCV (%.2f ms)" \
          % (imgElapsedTime * 1000)
        img_num += 1
  
  print "[time] prepareImages (%.2f ms):" % ((timeit.default_timer() - startTime) * 1000)

  return (g_inputs, inputImageFiles)

def prepareFpgaInputs(inputs):
  fpgaInputs = xdnn.prepareInputsForFpga(inputs, g_fpgaCfgFile, g_scaleB, -1, g_firstFpgaLayerName)

  return fpgaInputs

def prepareOutput(num):
  (fpgaOutput, fpgaHandle) \
     = xdnn.makeFPGAFloatArray(g_fpgaOutputSize * num)

  return fpgaOutput

def getGoldenMap(goldenFile, labelFile):
  golden = []
  with open(goldenFile, 'r') as f:
    for line in f:
      golden.append(line.strip())

  labelMap = {} # labelId -> label idx
  with open(labelFile, 'r') as f:
    for lineNum, line in enumerate(f):
      fullLabel = line.strip()
      words = fullLabel.split()
      labelId = words[0]
      labelMap[labelId] = lineNum

  goldenMap = {} # file idx -> label idx
  for idx in range(len(golden)):
    labelId = golden[idx]
    goldenMap[idx] = labelMap[labelId]

  return goldenMap

def checkAccuracy(fname, result, goldenMap):
  # get idx from file name ILSVRC2012_val_00031091.JPEG
  words = fname.split("_") 
  words = words[-1].split(".")
  numStr = words[0]
  idx = int(numStr) - 1

  goldenIdx = goldenMap[idx]

  # result is in the form [(value, idx), (value, idx), ...]
  for i,(val,idx) in enumerate(result):
    if i == 0 and idx == goldenIdx:
      return (1, 1)
    elif idx == goldenIdx:
      return (0, 1)

  return (0, 0)

def printClassification(output, outputSize, inputImageFiles, labelFile, goldenMap=None):
  labels = []
  with open(labelFile, 'r') as f:
    for line in f:
      labels.append(line.strip())

  idxArr = []
  for i in range(outputSize):
    idxArr.append(i)

  top1count = 0
  top5count = 0

  print "\n"
  for i in range(len(inputImageFiles)):
    inputImage = "for %s " % inputImageFiles[i]

    print "---------- Prediction %d %s----------" % (i, inputImage)
    startIdx = i * outputSize

    vals = output[startIdx:startIdx + outputSize]
    top5 = sorted(zip(vals, idxArr), reverse=True)[:5]

    for j in range(len(top5)):
      print "%.4f - \"%s\"" % (top5[j][0], labels[top5[j][1]])
    print ""

    if goldenMap != None:
      (t1, t5) = checkAccuracy(inputImageFiles[i], top5, goldenMap)
      top1count += t1
      top5count += t5

  return (top1count, top5count)

if __name__ == '__main__':
  main()

